# Assembler, Linker and Emulator

# Task 1: Assembler

## Introduction
The goal of this task was to implement a **single-pass assembler** for the processor described in the provided specification. The assembler reads a **text file containing source assembly code** and generates an output file representing the target program. Optionally, a binary file can also be produced for easier loading into a linker.

The program format is based on a simplified educational variant of the **ELF format**. Modifications to sections, relocation record types, or other fields were allowed if necessary to match the target architecture. Undefined details were handled following **GNU assembler principles**.


## Features & Directives

### General Rules
- Each line may contain **at most one assembler instruction or directive**.  
- Comments starting with `#` are **ignored**.  
- Labels (ending with `:`) must appear at the **start of a line**, optionally after spaces, and can stand alone.  

### Supported Directives
- `.global <symbol_list>` – Export one or more symbols  
- `.extern <symbol_list>` – Import one or more symbols  
- `.section <section_name>` – Start a new assembler section  
- `.word <symbol_or_literal_list>` – Allocate 4 bytes per initializer  
- `.skip <literal>` – Allocate a space of the given size, initialized to zero  
- `.ascii <string>` – Allocate one byte per character (ASCII)  
- `.end` – End assembly; remaining input is ignored  

### Supported Instructions
The assembler supports instructions such as:
- **Control:** `halt`, `int`, `iret`, `call`, `ret`, `jmp`, `beq`, `bne`, `bgt`  
- **Stack operations:** `push`, `pop`  
- **Data movement:** `xchg`, `ld`, `st`  
- **Arithmetic / Logic:** `add`, `sub`, `mul`, `div`, `not`, `and`, `or`, `xor`, `shl`, `shr`  
- **CSR operations:** `csrrd`, `csrwr`  

Registers are represented as:
- General-purpose: `r0`–`r15` (r14 = sp, r15 = pc)  
- Control/Status registers: `status`, `handler`, `cause`  

Operands can be:
- Immediate: `$<literal>` or `$<symbol>`  
- Memory: `<literal>`, `<symbol>`, `[%<reg>]`, `[%<reg> + <literal>]`, `[%<reg> + <symbol>]`  
- Register: `%<reg>`  

---

## Running the Assembler


The assembler accepts the following command line options:

- `-o <output_file_name>`  
  Sets the name of the output file that will contain the result of the assembly process.

### Usage Example
To assemble the source code in `input.s` and generate an output file `output.o`, use:

```bash
./asembler -o output.o input.s
```
# Task 2: Linker

## Introduction

The goal of this task is to implement a target-independent linker that, based on metadata (symbol tables, relocation records, etc.), links one or more object programs generated by the assembler from Task 1.

The linker's input consists of the assembler outputs, with the possibility of providing multiple object programs to be linked. By default, the linker places sections starting from address 0, one immediately after another in the order they are defined within the object program. When multiple object programs are provided, the linker processes them in the order specified on the command line. If a section with the same name already exists, it is placed starting from the end of the previous section with the same name, creating aggregation of identically named sections, without overlapping with subsequent sections by pushing them to higher addresses.



## Running the Linker

The linker supports the following command line options, which can be provided in any order:

- `-o <output_file_name>`  
  Sets the name of the output file that will contain the result of the linking process.

- `-place=<section_name>@<address>`  
  Explicitly defines the starting address for a section with the given name.  
  Multiple `-place` options can be used for different section names. Sections without a `-place` option are placed sequentially after the last section at the highest address by default.

- `-hex`  
  Instructs the linker to generate an output as a set of address-content pairs for memory initialization. Only addresses with defined initial content are included. Example format:

- `-relocatable`  
Generates a relocatable output in the same format as the assembler output, ignoring any `-place` options. The resulting program can later be used as input for the linker.

### Usage Example
```bash
./linker -hex
-place=data@0x4000F000 -place=text@0x40000000
-o mem_content.hex
input1.o input2.o
```
# Task 3: Emulator

##  Introduction

The task aims to implement an emulator for the target architecture. The emulator handles the execution of programs generated by the linker with the `-hex` option. It supports the core components of the computer system, as well as the terminal peripheral.  

### Usage Example
```bash
./emulator mem_content.hex
```
Once the emulator is started, the only output to the console will be the output directly from the user program. Emulation terminates when the emulated processor executes the `halt` instruction from the user program.

After the emulation ends, the implementation should print the state of the emulated processor in the following format:
```
-----------------------------------------------------------------
Emulated processor executed halt instruction
Emulated processor state:
r0=0x00000000   r1=0x00000000   r2=0x00000000   r3=0x00000000
r4=0x00000000   r5=0x00000000   r6=0x00000000   r7=0x00000000
r8=0x00000000   r9=0x00000000   r10=0x00000000  r11=0x00000000
r12=0x00000000  r13=0x00000000  r14=0x00000000  r15=0x00000000
```





